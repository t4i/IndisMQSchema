// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_
#define FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_

#include "flatbuffers/flatbuffers.h"

namespace IndisMQ {

struct Ver;

struct Imq;
struct ImqT;

enum class MsgType : int8_t {
  NONE = 0,
  SINGLE = 1,
  CAST = 2,
  QUEUE = 3,
  CMD = 4,
  MIN = NONE,
  MAX = CMD
};

inline const char **EnumNamesMsgType() {
  static const char *names[] = { "NONE", "SINGLE", "CAST", "QUEUE", "CMD", nullptr };
  return names;
}

inline const char *EnumNameMsgType(MsgType e) { return EnumNamesMsgType()[static_cast<int>(e)]; }

enum class Action : int8_t {
  NONE = 0,
  GET = 1,
  SET = 2,
  NEW = 3,
  APPEND = 4,
  REPLACE = 5,
  UPDATE = 6,
  DELETE = 7,
  MIN = NONE,
  MAX = DELETE
};

inline const char **EnumNamesAction() {
  static const char *names[] = { "NONE", "GET", "SET", "NEW", "APPEND", "REPLACE", "UPDATE", "DELETE", nullptr };
  return names;
}

inline const char *EnumNameAction(Action e) { return EnumNamesAction()[static_cast<int>(e)]; }

enum class Cmd : int8_t {
  NONE = 0,
  SUB = 1,
  UNSUB = 2,
  SYN = 3,
  READY = 4,
  MIN = NONE,
  MAX = READY
};

inline const char **EnumNamesCmd() {
  static const char *names[] = { "NONE", "SUB", "UNSUB", "SYN", "READY", nullptr };
  return names;
}

inline const char *EnumNameCmd(Cmd e) { return EnumNamesCmd()[static_cast<int>(e)]; }

enum class Sts : int8_t {
  NONE = 0,
  ERROR = 1,
  REQ = 2,
  REP = 3,
  SEQ = 4,
  CANCEL = 5,
  SUCCESS = 6,
  ACK = 7,
  MIN = NONE,
  MAX = ACK
};

inline const char **EnumNamesSts() {
  static const char *names[] = { "NONE", "ERROR", "REQ", "REP", "SEQ", "CANCEL", "SUCCESS", "ACK", nullptr };
  return names;
}

inline const char *EnumNameSts(Sts e) { return EnumNamesSts()[static_cast<int>(e)]; }

enum class Err : int8_t {
  NONE = 0,
  NO_HANDLER = 1,
  INVALID = 2,
  REMOTE = 3,
  TIMEOUT = 4,
  MIN = NONE,
  MAX = TIMEOUT
};

inline const char **EnumNamesErr() {
  static const char *names[] = { "NONE", "NO_HANDLER", "INVALID", "REMOTE", "TIMEOUT", nullptr };
  return names;
}

inline const char *EnumNameErr(Err e) { return EnumNamesErr()[static_cast<int>(e)]; }

MANUALLY_ALIGNED_STRUCT(1) Ver FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t Major_;
  int8_t Minor_;

 public:
  Ver() { memset(this, 0, sizeof(Ver)); }
  Ver(const Ver &_o) { memcpy(this, &_o, sizeof(Ver)); }
  Ver(int8_t _Major, int8_t _Minor)
    : Major_(flatbuffers::EndianScalar(_Major)), Minor_(flatbuffers::EndianScalar(_Minor)) { }

  int8_t Major() const { return flatbuffers::EndianScalar(Major_); }
  void mutate_Major(int8_t _Major) { flatbuffers::WriteScalar(&Major_, _Major); }
  int8_t Minor() const { return flatbuffers::EndianScalar(Minor_); }
  void mutate_Minor(int8_t _Minor) { flatbuffers::WriteScalar(&Minor_, _Minor); }
};
STRUCT_END(Ver, 2);

struct ImqT : public flatbuffers::NativeTable {
  std::vector<uint8_t> Body;
  std::string From;
  std::string To;
  bool Broker;
  Cmd Cmd;
  std::string MsgId;
  MsgType MsgType;
  Sts Sts;
  std::string Path;
  Err Err;
  std::string StsMsg;
  bool Callback;
  std::unique_ptr<Ver> Ver;
};

struct Imq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BODY = 4,
    VT_FROM = 6,
    VT_TO = 8,
    VT_BROKER = 10,
    VT_CMD = 12,
    VT_MSGID = 14,
    VT_MSGTYPE = 16,
    VT_STS = 18,
    VT_PATH = 20,
    VT_ERR = 22,
    VT_STSMSG = 24,
    VT_CALLBACK = 26,
    VT_VER = 28
  };
  const flatbuffers::Vector<uint8_t> *Body() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BODY); }
  flatbuffers::Vector<uint8_t> *mutable_Body() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BODY); }
  const flatbuffers::String *From() const { return GetPointer<const flatbuffers::String *>(VT_FROM); }
  flatbuffers::String *mutable_From() { return GetPointer<flatbuffers::String *>(VT_FROM); }
  const flatbuffers::String *To() const { return GetPointer<const flatbuffers::String *>(VT_TO); }
  flatbuffers::String *mutable_To() { return GetPointer<flatbuffers::String *>(VT_TO); }
  bool Broker() const { return GetField<uint8_t>(VT_BROKER, 0) != 0; }
  bool mutate_Broker(bool _Broker) { return SetField(VT_BROKER, static_cast<uint8_t>(_Broker)); }
  IndisMQ::Cmd Cmd() const { return static_cast<IndisMQ::Cmd>(GetField<int8_t>(VT_CMD, 0)); }
  bool mutate_Cmd(IndisMQ::Cmd _Cmd) { return SetField(VT_CMD, static_cast<int8_t>(_Cmd)); }
  const flatbuffers::String *MsgId() const { return GetPointer<const flatbuffers::String *>(VT_MSGID); }
  flatbuffers::String *mutable_MsgId() { return GetPointer<flatbuffers::String *>(VT_MSGID); }
  IndisMQ::MsgType MsgType() const { return static_cast<IndisMQ::MsgType>(GetField<int8_t>(VT_MSGTYPE, 0)); }
  bool mutate_MsgType(IndisMQ::MsgType _MsgType) { return SetField(VT_MSGTYPE, static_cast<int8_t>(_MsgType)); }
  IndisMQ::Sts Sts() const { return static_cast<IndisMQ::Sts>(GetField<int8_t>(VT_STS, 0)); }
  bool mutate_Sts(IndisMQ::Sts _Sts) { return SetField(VT_STS, static_cast<int8_t>(_Sts)); }
  const flatbuffers::String *Path() const { return GetPointer<const flatbuffers::String *>(VT_PATH); }
  flatbuffers::String *mutable_Path() { return GetPointer<flatbuffers::String *>(VT_PATH); }
  IndisMQ::Err Err() const { return static_cast<IndisMQ::Err>(GetField<int8_t>(VT_ERR, 0)); }
  bool mutate_Err(IndisMQ::Err _Err) { return SetField(VT_ERR, static_cast<int8_t>(_Err)); }
  const flatbuffers::String *StsMsg() const { return GetPointer<const flatbuffers::String *>(VT_STSMSG); }
  flatbuffers::String *mutable_StsMsg() { return GetPointer<flatbuffers::String *>(VT_STSMSG); }
  bool Callback() const { return GetField<uint8_t>(VT_CALLBACK, 0) != 0; }
  bool mutate_Callback(bool _Callback) { return SetField(VT_CALLBACK, static_cast<uint8_t>(_Callback)); }
  const IndisMQ::Ver *Ver() const { return GetStruct<const IndisMQ::Ver *>(VT_VER); }
  IndisMQ::Ver *mutable_Ver() { return GetStruct<IndisMQ::Ver *>(VT_VER); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BODY) &&
           verifier.Verify(Body()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FROM) &&
           verifier.Verify(From()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TO) &&
           verifier.Verify(To()) &&
           VerifyField<uint8_t>(verifier, VT_BROKER) &&
           VerifyField<int8_t>(verifier, VT_CMD) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MSGID) &&
           verifier.Verify(MsgId()) &&
           VerifyField<int8_t>(verifier, VT_MSGTYPE) &&
           VerifyField<int8_t>(verifier, VT_STS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PATH) &&
           verifier.Verify(Path()) &&
           VerifyField<int8_t>(verifier, VT_ERR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_STSMSG) &&
           verifier.Verify(StsMsg()) &&
           VerifyField<uint8_t>(verifier, VT_CALLBACK) &&
           VerifyField<IndisMQ::Ver>(verifier, VT_VER) &&
           verifier.EndTable();
  }
  ImqT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct ImqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Body(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Body) { fbb_.AddOffset(Imq::VT_BODY, Body); }
  void add_From(flatbuffers::Offset<flatbuffers::String> From) { fbb_.AddOffset(Imq::VT_FROM, From); }
  void add_To(flatbuffers::Offset<flatbuffers::String> To) { fbb_.AddOffset(Imq::VT_TO, To); }
  void add_Broker(bool Broker) { fbb_.AddElement<uint8_t>(Imq::VT_BROKER, static_cast<uint8_t>(Broker), 0); }
  void add_Cmd(Cmd Cmd) { fbb_.AddElement<int8_t>(Imq::VT_CMD, static_cast<int8_t>(Cmd), 0); }
  void add_MsgId(flatbuffers::Offset<flatbuffers::String> MsgId) { fbb_.AddOffset(Imq::VT_MSGID, MsgId); }
  void add_MsgType(MsgType MsgType) { fbb_.AddElement<int8_t>(Imq::VT_MSGTYPE, static_cast<int8_t>(MsgType), 0); }
  void add_Sts(Sts Sts) { fbb_.AddElement<int8_t>(Imq::VT_STS, static_cast<int8_t>(Sts), 0); }
  void add_Path(flatbuffers::Offset<flatbuffers::String> Path) { fbb_.AddOffset(Imq::VT_PATH, Path); }
  void add_Err(Err Err) { fbb_.AddElement<int8_t>(Imq::VT_ERR, static_cast<int8_t>(Err), 0); }
  void add_StsMsg(flatbuffers::Offset<flatbuffers::String> StsMsg) { fbb_.AddOffset(Imq::VT_STSMSG, StsMsg); }
  void add_Callback(bool Callback) { fbb_.AddElement<uint8_t>(Imq::VT_CALLBACK, static_cast<uint8_t>(Callback), 0); }
  void add_Ver(const Ver *Ver) { fbb_.AddStruct(Imq::VT_VER, Ver); }
  ImqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ImqBuilder &operator=(const ImqBuilder &);
  flatbuffers::Offset<Imq> Finish() {
    auto o = flatbuffers::Offset<Imq>(fbb_.EndTable(start_, 13));
    return o;
  }
};

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Body = 0,
    flatbuffers::Offset<flatbuffers::String> From = 0,
    flatbuffers::Offset<flatbuffers::String> To = 0,
    bool Broker = false,
    Cmd Cmd = Cmd::NONE,
    flatbuffers::Offset<flatbuffers::String> MsgId = 0,
    MsgType MsgType = MsgType::NONE,
    Sts Sts = Sts::NONE,
    flatbuffers::Offset<flatbuffers::String> Path = 0,
    Err Err = Err::NONE,
    flatbuffers::Offset<flatbuffers::String> StsMsg = 0,
    bool Callback = false,
    const Ver *Ver = 0) {
  ImqBuilder builder_(_fbb);
  builder_.add_Ver(Ver);
  builder_.add_StsMsg(StsMsg);
  builder_.add_Path(Path);
  builder_.add_MsgId(MsgId);
  builder_.add_To(To);
  builder_.add_From(From);
  builder_.add_Body(Body);
  builder_.add_Callback(Callback);
  builder_.add_Err(Err);
  builder_.add_Sts(Sts);
  builder_.add_MsgType(MsgType);
  builder_.add_Cmd(Cmd);
  builder_.add_Broker(Broker);
  return builder_.Finish();
}

inline flatbuffers::Offset<Imq> CreateImqDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *Body = nullptr,
    const char *From = nullptr,
    const char *To = nullptr,
    bool Broker = false,
    Cmd Cmd = Cmd::NONE,
    const char *MsgId = nullptr,
    MsgType MsgType = MsgType::NONE,
    Sts Sts = Sts::NONE,
    const char *Path = nullptr,
    Err Err = Err::NONE,
    const char *StsMsg = nullptr,
    bool Callback = false,
    const Ver *Ver = 0) {
  return CreateImq(_fbb, Body ? _fbb.CreateVector<uint8_t>(*Body) : 0, From ? _fbb.CreateString(From) : 0, To ? _fbb.CreateString(To) : 0, Broker, Cmd, MsgId ? _fbb.CreateString(MsgId) : 0, MsgType, Sts, Path ? _fbb.CreateString(Path) : 0, Err, StsMsg ? _fbb.CreateString(StsMsg) : 0, Callback, Ver);
}

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb, const ImqT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

inline ImqT *Imq::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ImqT();
  { auto _e = Body(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Body.push_back(_e->Get(_i)); } } };
  { auto _e = From(); if (_e) _o->From = _e->str(); };
  { auto _e = To(); if (_e) _o->To = _e->str(); };
  { auto _e = Broker(); _o->Broker = _e; };
  { auto _e = Cmd(); _o->Cmd = _e; };
  { auto _e = MsgId(); if (_e) _o->MsgId = _e->str(); };
  { auto _e = MsgType(); _o->MsgType = _e; };
  { auto _e = Sts(); _o->Sts = _e; };
  { auto _e = Path(); if (_e) _o->Path = _e->str(); };
  { auto _e = Err(); _o->Err = _e; };
  { auto _e = StsMsg(); if (_e) _o->StsMsg = _e->str(); };
  { auto _e = Callback(); _o->Callback = _e; };
  { auto _e = Ver(); if (_e) _o->Ver = std::unique_ptr<IndisMQ::Ver>(new IndisMQ::Ver(*_e)); };
  return _o;
}

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb, const ImqT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateImq(_fbb,
    _o->Body.size() ? _fbb.CreateVector(_o->Body) : 0,
    _o->From.size() ? _fbb.CreateString(_o->From) : 0,
    _o->To.size() ? _fbb.CreateString(_o->To) : 0,
    _o->Broker,
    _o->Cmd,
    _o->MsgId.size() ? _fbb.CreateString(_o->MsgId) : 0,
    _o->MsgType,
    _o->Sts,
    _o->Path.size() ? _fbb.CreateString(_o->Path) : 0,
    _o->Err,
    _o->StsMsg.size() ? _fbb.CreateString(_o->StsMsg) : 0,
    _o->Callback,
    _o->Ver ? _o->Ver.get() : 0);
}

inline const IndisMQ::Imq *GetImq(const void *buf) {
  return flatbuffers::GetRoot<IndisMQ::Imq>(buf);
}

inline Imq *GetMutableImq(void *buf) {
  return flatbuffers::GetMutableRoot<Imq>(buf);
}

inline const char *ImqIdentifier() {
  return "0001";
}

inline bool ImqBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(buf, ImqIdentifier());
}

inline bool VerifyImqBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<IndisMQ::Imq>(ImqIdentifier());
}

inline void FinishImqBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<IndisMQ::Imq> root) {
  fbb.Finish(root, ImqIdentifier());
}

inline std::unique_ptr<ImqT> UnPackImq(const void *buf, const flatbuffers::resolver_function_t *resolver = nullptr) {
  return std::unique_ptr<ImqT>(GetImq(buf)->UnPack(resolver));
}

}  // namespace IndisMQ

#endif  // FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_
