// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_
#define FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_

#include "flatbuffers/flatbuffers.h"

namespace IndisMQ {

struct Ver;

struct Imq;

struct Auth;

enum MsgType {
  MsgType_NONE = 0,
  MsgType_SINGLE = 1,
  MsgType_CAST = 2,
  MsgType_QUEUE = 3,
  MsgType_CMD = 4,
  MsgType_MIN = MsgType_NONE,
  MsgType_MAX = MsgType_CMD
};

inline const char **EnumNamesMsgType() {
  static const char *names[] = { "NONE", "SINGLE", "CAST", "QUEUE", "CMD", nullptr };
  return names;
}

inline const char *EnumNameMsgType(MsgType e) { return EnumNamesMsgType()[static_cast<int>(e)]; }

enum Action {
  Action_NONE = 0,
  Action_GET = 1,
  Action_SET = 2,
  Action_NEW = 3,
  Action_APPEND = 4,
  Action_REPLACE = 5,
  Action_UPDATE = 6,
  Action_DELETE = 7,
  Action_MIN = Action_NONE,
  Action_MAX = Action_DELETE
};

inline const char **EnumNamesAction() {
  static const char *names[] = { "NONE", "GET", "SET", "NEW", "APPEND", "REPLACE", "UPDATE", "DELETE", nullptr };
  return names;
}

inline const char *EnumNameAction(Action e) { return EnumNamesAction()[static_cast<int>(e)]; }

enum Cmd {
  Cmd_NONE = 0,
  Cmd_SUB = 1,
  Cmd_UNSUB = 2,
  Cmd_SYN = 3,
  Cmd_READY = 4,
  Cmd_MIN = Cmd_NONE,
  Cmd_MAX = Cmd_READY
};

inline const char **EnumNamesCmd() {
  static const char *names[] = { "NONE", "SUB", "UNSUB", "SYN", "READY", nullptr };
  return names;
}

inline const char *EnumNameCmd(Cmd e) { return EnumNamesCmd()[static_cast<int>(e)]; }

enum Sts {
  Sts_NONE = 0,
  Sts_ERROR = 1,
  Sts_REQ = 2,
  Sts_REP = 3,
  Sts_SEQ = 4,
  Sts_CANCEL = 5,
  Sts_SUCCESS = 6,
  Sts_ACK = 7,
  Sts_MIN = Sts_NONE,
  Sts_MAX = Sts_ACK
};

inline const char **EnumNamesSts() {
  static const char *names[] = { "NONE", "ERROR", "REQ", "REP", "SEQ", "CANCEL", "SUCCESS", "ACK", nullptr };
  return names;
}

inline const char *EnumNameSts(Sts e) { return EnumNamesSts()[static_cast<int>(e)]; }

enum Err {
  Err_NONE = 0,
  Err_NO_HANDLER = 1,
  Err_INVALID = 2,
  Err_REMOTE = 3,
  Err_TIMEOUT = 4,
  Err_MIN = Err_NONE,
  Err_MAX = Err_TIMEOUT
};

inline const char **EnumNamesErr() {
  static const char *names[] = { "NONE", "NO_HANDLER", "INVALID", "REMOTE", "TIMEOUT", nullptr };
  return names;
}

inline const char *EnumNameErr(Err e) { return EnumNamesErr()[static_cast<int>(e)]; }

enum AuthErr {
  AuthErr_NONE = 0,
  AuthErr_INVALID = 1,
  AuthErr_UNAUTHORIZED = 2,
  AuthErr_MIN = AuthErr_NONE,
  AuthErr_MAX = AuthErr_UNAUTHORIZED
};

inline const char **EnumNamesAuthErr() {
  static const char *names[] = { "NONE", "INVALID", "UNAUTHORIZED", nullptr };
  return names;
}

inline const char *EnumNameAuthErr(AuthErr e) { return EnumNamesAuthErr()[static_cast<int>(e)]; }

MANUALLY_ALIGNED_STRUCT(1) Ver FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t Major_;
  int8_t Minor_;

 public:
  Ver() { memset(this, 0, sizeof(Ver)); }
  Ver(const Ver &_o) { memcpy(this, &_o, sizeof(Ver)); }
  Ver(int8_t _Major, int8_t _Minor)
    : Major_(flatbuffers::EndianScalar(_Major)), Minor_(flatbuffers::EndianScalar(_Minor)) { }

  int8_t Major() const { return flatbuffers::EndianScalar(Major_); }
  int8_t Minor() const { return flatbuffers::EndianScalar(Minor_); }
};
STRUCT_END(Ver, 2);

struct Imq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BODY = 4,
    VT_FROM = 6,
    VT_TO = 8,
    VT_BROKER = 10,
    VT_CMD = 12,
    VT_MSGID = 14,
    VT_MSGTYPE = 16,
    VT_STS = 18,
    VT_PATH = 20,
    VT_ERR = 22,
    VT_STSMSG = 24,
    VT_CALLBACK = 26,
    VT_VER = 28,
    VT_AUTH = 30,
    VT_USER = 32
  };
  const flatbuffers::Vector<uint8_t> *Body() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BODY); }
  const flatbuffers::String *From() const { return GetPointer<const flatbuffers::String *>(VT_FROM); }
  const flatbuffers::String *To() const { return GetPointer<const flatbuffers::String *>(VT_TO); }
  bool Broker() const { return GetField<uint8_t>(VT_BROKER, 0) != 0; }
  Cmd Cmd() const { return static_cast<Cmd>(GetField<int8_t>(VT_CMD, 0)); }
  const flatbuffers::String *MsgId() const { return GetPointer<const flatbuffers::String *>(VT_MSGID); }
  MsgType MsgType() const { return static_cast<MsgType>(GetField<int8_t>(VT_MSGTYPE, 0)); }
  Sts Sts() const { return static_cast<Sts>(GetField<int8_t>(VT_STS, 0)); }
  const flatbuffers::String *Path() const { return GetPointer<const flatbuffers::String *>(VT_PATH); }
  Err Err() const { return static_cast<Err>(GetField<int8_t>(VT_ERR, 0)); }
  const flatbuffers::String *StsMsg() const { return GetPointer<const flatbuffers::String *>(VT_STSMSG); }
  bool Callback() const { return GetField<uint8_t>(VT_CALLBACK, 0) != 0; }
  const Ver *Ver() const { return GetStruct<const Ver *>(VT_VER); }
  const Auth *Auth() const { return GetPointer<const Auth *>(VT_AUTH); }
  const flatbuffers::String *User() const { return GetPointer<const flatbuffers::String *>(VT_USER); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BODY) &&
           verifier.Verify(Body()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FROM) &&
           verifier.Verify(From()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TO) &&
           verifier.Verify(To()) &&
           VerifyField<uint8_t>(verifier, VT_BROKER) &&
           VerifyField<int8_t>(verifier, VT_CMD) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MSGID) &&
           verifier.Verify(MsgId()) &&
           VerifyField<int8_t>(verifier, VT_MSGTYPE) &&
           VerifyField<int8_t>(verifier, VT_STS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PATH) &&
           verifier.Verify(Path()) &&
           VerifyField<int8_t>(verifier, VT_ERR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_STSMSG) &&
           verifier.Verify(StsMsg()) &&
           VerifyField<uint8_t>(verifier, VT_CALLBACK) &&
           VerifyField<Ver>(verifier, VT_VER) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_AUTH) &&
           verifier.VerifyTable(Auth()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USER) &&
           verifier.Verify(User()) &&
           verifier.EndTable();
  }
};

struct ImqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Body(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Body) { fbb_.AddOffset(Imq::VT_BODY, Body); }
  void add_From(flatbuffers::Offset<flatbuffers::String> From) { fbb_.AddOffset(Imq::VT_FROM, From); }
  void add_To(flatbuffers::Offset<flatbuffers::String> To) { fbb_.AddOffset(Imq::VT_TO, To); }
  void add_Broker(bool Broker) { fbb_.AddElement<uint8_t>(Imq::VT_BROKER, static_cast<uint8_t>(Broker), 0); }
  void add_Cmd(Cmd Cmd) { fbb_.AddElement<int8_t>(Imq::VT_CMD, static_cast<int8_t>(Cmd), 0); }
  void add_MsgId(flatbuffers::Offset<flatbuffers::String> MsgId) { fbb_.AddOffset(Imq::VT_MSGID, MsgId); }
  void add_MsgType(MsgType MsgType) { fbb_.AddElement<int8_t>(Imq::VT_MSGTYPE, static_cast<int8_t>(MsgType), 0); }
  void add_Sts(Sts Sts) { fbb_.AddElement<int8_t>(Imq::VT_STS, static_cast<int8_t>(Sts), 0); }
  void add_Path(flatbuffers::Offset<flatbuffers::String> Path) { fbb_.AddOffset(Imq::VT_PATH, Path); }
  void add_Err(Err Err) { fbb_.AddElement<int8_t>(Imq::VT_ERR, static_cast<int8_t>(Err), 0); }
  void add_StsMsg(flatbuffers::Offset<flatbuffers::String> StsMsg) { fbb_.AddOffset(Imq::VT_STSMSG, StsMsg); }
  void add_Callback(bool Callback) { fbb_.AddElement<uint8_t>(Imq::VT_CALLBACK, static_cast<uint8_t>(Callback), 0); }
  void add_Ver(const Ver *Ver) { fbb_.AddStruct(Imq::VT_VER, Ver); }
  void add_Auth(flatbuffers::Offset<Auth> Auth) { fbb_.AddOffset(Imq::VT_AUTH, Auth); }
  void add_User(flatbuffers::Offset<flatbuffers::String> User) { fbb_.AddOffset(Imq::VT_USER, User); }
  ImqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ImqBuilder &operator=(const ImqBuilder &);
  flatbuffers::Offset<Imq> Finish() {
    auto o = flatbuffers::Offset<Imq>(fbb_.EndTable(start_, 15));
    return o;
  }
};

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Body = 0,
    flatbuffers::Offset<flatbuffers::String> From = 0,
    flatbuffers::Offset<flatbuffers::String> To = 0,
    bool Broker = false,
    Cmd Cmd = Cmd_NONE,
    flatbuffers::Offset<flatbuffers::String> MsgId = 0,
    MsgType MsgType = MsgType_NONE,
    Sts Sts = Sts_NONE,
    flatbuffers::Offset<flatbuffers::String> Path = 0,
    Err Err = Err_NONE,
    flatbuffers::Offset<flatbuffers::String> StsMsg = 0,
    bool Callback = false,
    const Ver *Ver = 0,
    flatbuffers::Offset<Auth> Auth = 0,
    flatbuffers::Offset<flatbuffers::String> User = 0) {
  ImqBuilder builder_(_fbb);
  builder_.add_User(User);
  builder_.add_Auth(Auth);
  builder_.add_Ver(Ver);
  builder_.add_StsMsg(StsMsg);
  builder_.add_Path(Path);
  builder_.add_MsgId(MsgId);
  builder_.add_To(To);
  builder_.add_From(From);
  builder_.add_Body(Body);
  builder_.add_Callback(Callback);
  builder_.add_Err(Err);
  builder_.add_Sts(Sts);
  builder_.add_MsgType(MsgType);
  builder_.add_Cmd(Cmd);
  builder_.add_Broker(Broker);
  return builder_.Finish();
}

inline flatbuffers::Offset<Imq> CreateImqDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *Body = nullptr,
    const char *From = nullptr,
    const char *To = nullptr,
    bool Broker = false,
    Cmd Cmd = Cmd_NONE,
    const char *MsgId = nullptr,
    MsgType MsgType = MsgType_NONE,
    Sts Sts = Sts_NONE,
    const char *Path = nullptr,
    Err Err = Err_NONE,
    const char *StsMsg = nullptr,
    bool Callback = false,
    const Ver *Ver = 0,
    flatbuffers::Offset<Auth> Auth = 0,
    const char *User = nullptr) {
  return CreateImq(_fbb, Body ? _fbb.CreateVector<uint8_t>(*Body) : 0, From ? _fbb.CreateString(From) : 0, To ? _fbb.CreateString(To) : 0, Broker, Cmd, MsgId ? _fbb.CreateString(MsgId) : 0, MsgType, Sts, Path ? _fbb.CreateString(Path) : 0, Err, StsMsg ? _fbb.CreateString(StsMsg) : 0, Callback, Ver, Auth, User ? _fbb.CreateString(User) : 0);
}

struct Auth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USER = 4,
    VT_PASS = 6,
    VT_TOKEN = 8,
    VT_DOMAIN = 10,
    VT_REQUIRED = 12,
    VT_TIMESTAMP = 14,
    VT_NONCE = 16,
    VT_CIPHERS = 18,
    VT_ALG = 20,
    VT_ERR = 22,
    VT_ERRMSG = 24,
    VT_MSG = 26
  };
  const flatbuffers::String *User() const { return GetPointer<const flatbuffers::String *>(VT_USER); }
  const flatbuffers::String *Pass() const { return GetPointer<const flatbuffers::String *>(VT_PASS); }
  const flatbuffers::String *Token() const { return GetPointer<const flatbuffers::String *>(VT_TOKEN); }
  const flatbuffers::String *Domain() const { return GetPointer<const flatbuffers::String *>(VT_DOMAIN); }
  bool Required() const { return GetField<uint8_t>(VT_REQUIRED, 0) != 0; }
  int64_t Timestamp() const { return GetField<int64_t>(VT_TIMESTAMP, 0); }
  const flatbuffers::String *Nonce() const { return GetPointer<const flatbuffers::String *>(VT_NONCE); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *Ciphers() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CIPHERS); }
  const flatbuffers::String *Alg() const { return GetPointer<const flatbuffers::String *>(VT_ALG); }
  AuthErr Err() const { return static_cast<AuthErr>(GetField<int8_t>(VT_ERR, 0)); }
  const flatbuffers::String *ErrMsg() const { return GetPointer<const flatbuffers::String *>(VT_ERRMSG); }
  const flatbuffers::String *Msg() const { return GetPointer<const flatbuffers::String *>(VT_MSG); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USER) &&
           verifier.Verify(User()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASS) &&
           verifier.Verify(Pass()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TOKEN) &&
           verifier.Verify(Token()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DOMAIN) &&
           verifier.Verify(Domain()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRED) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NONCE) &&
           verifier.Verify(Nonce()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CIPHERS) &&
           verifier.Verify(Ciphers()) &&
           verifier.VerifyVectorOfStrings(Ciphers()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ALG) &&
           verifier.Verify(Alg()) &&
           VerifyField<int8_t>(verifier, VT_ERR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ERRMSG) &&
           verifier.Verify(ErrMsg()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MSG) &&
           verifier.Verify(Msg()) &&
           verifier.EndTable();
  }
};

struct AuthBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_User(flatbuffers::Offset<flatbuffers::String> User) { fbb_.AddOffset(Auth::VT_USER, User); }
  void add_Pass(flatbuffers::Offset<flatbuffers::String> Pass) { fbb_.AddOffset(Auth::VT_PASS, Pass); }
  void add_Token(flatbuffers::Offset<flatbuffers::String> Token) { fbb_.AddOffset(Auth::VT_TOKEN, Token); }
  void add_Domain(flatbuffers::Offset<flatbuffers::String> Domain) { fbb_.AddOffset(Auth::VT_DOMAIN, Domain); }
  void add_Required(bool Required) { fbb_.AddElement<uint8_t>(Auth::VT_REQUIRED, static_cast<uint8_t>(Required), 0); }
  void add_Timestamp(int64_t Timestamp) { fbb_.AddElement<int64_t>(Auth::VT_TIMESTAMP, Timestamp, 0); }
  void add_Nonce(flatbuffers::Offset<flatbuffers::String> Nonce) { fbb_.AddOffset(Auth::VT_NONCE, Nonce); }
  void add_Ciphers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> Ciphers) { fbb_.AddOffset(Auth::VT_CIPHERS, Ciphers); }
  void add_Alg(flatbuffers::Offset<flatbuffers::String> Alg) { fbb_.AddOffset(Auth::VT_ALG, Alg); }
  void add_Err(AuthErr Err) { fbb_.AddElement<int8_t>(Auth::VT_ERR, static_cast<int8_t>(Err), 0); }
  void add_ErrMsg(flatbuffers::Offset<flatbuffers::String> ErrMsg) { fbb_.AddOffset(Auth::VT_ERRMSG, ErrMsg); }
  void add_Msg(flatbuffers::Offset<flatbuffers::String> Msg) { fbb_.AddOffset(Auth::VT_MSG, Msg); }
  AuthBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AuthBuilder &operator=(const AuthBuilder &);
  flatbuffers::Offset<Auth> Finish() {
    auto o = flatbuffers::Offset<Auth>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<Auth> CreateAuth(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> User = 0,
    flatbuffers::Offset<flatbuffers::String> Pass = 0,
    flatbuffers::Offset<flatbuffers::String> Token = 0,
    flatbuffers::Offset<flatbuffers::String> Domain = 0,
    bool Required = false,
    int64_t Timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> Nonce = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> Ciphers = 0,
    flatbuffers::Offset<flatbuffers::String> Alg = 0,
    AuthErr Err = AuthErr_NONE,
    flatbuffers::Offset<flatbuffers::String> ErrMsg = 0,
    flatbuffers::Offset<flatbuffers::String> Msg = 0) {
  AuthBuilder builder_(_fbb);
  builder_.add_Timestamp(Timestamp);
  builder_.add_Msg(Msg);
  builder_.add_ErrMsg(ErrMsg);
  builder_.add_Alg(Alg);
  builder_.add_Ciphers(Ciphers);
  builder_.add_Nonce(Nonce);
  builder_.add_Domain(Domain);
  builder_.add_Token(Token);
  builder_.add_Pass(Pass);
  builder_.add_User(User);
  builder_.add_Err(Err);
  builder_.add_Required(Required);
  return builder_.Finish();
}

inline flatbuffers::Offset<Auth> CreateAuthDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *User = nullptr,
    const char *Pass = nullptr,
    const char *Token = nullptr,
    const char *Domain = nullptr,
    bool Required = false,
    int64_t Timestamp = 0,
    const char *Nonce = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *Ciphers = nullptr,
    const char *Alg = nullptr,
    AuthErr Err = AuthErr_NONE,
    const char *ErrMsg = nullptr,
    const char *Msg = nullptr) {
  return CreateAuth(_fbb, User ? _fbb.CreateString(User) : 0, Pass ? _fbb.CreateString(Pass) : 0, Token ? _fbb.CreateString(Token) : 0, Domain ? _fbb.CreateString(Domain) : 0, Required, Timestamp, Nonce ? _fbb.CreateString(Nonce) : 0, Ciphers ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*Ciphers) : 0, Alg ? _fbb.CreateString(Alg) : 0, Err, ErrMsg ? _fbb.CreateString(ErrMsg) : 0, Msg ? _fbb.CreateString(Msg) : 0);
}

inline const IndisMQ::Imq *GetImq(const void *buf) {
  return flatbuffers::GetRoot<IndisMQ::Imq>(buf);
}

inline const char *ImqIdentifier() {
  return "0001";
}

inline bool ImqBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(buf, ImqIdentifier());
}

inline bool VerifyImqBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<IndisMQ::Imq>(ImqIdentifier());
}

inline void FinishImqBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<IndisMQ::Imq> root) {
  fbb.Finish(root, ImqIdentifier());
}

}  // namespace IndisMQ

#endif  // FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_
