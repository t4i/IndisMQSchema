// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_
#define FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_

#include "flatbuffers/flatbuffers.h"

namespace IndisMQ {

struct Imq;
struct ImqT;

struct KeyVal;
struct KeyValT;

enum class Action : int8_t {
  ACK = 0,
  GET = 1,
  HEAD = 2,
  POST = 3,
  PUT = 4,
  DELETE = 5,
  CONNECT = 6,
  OPTIONS = 7,
  TRACE = 8,
  PATCH = 9,
  RESPONSE = 10,
  SUBSCRIBE = 11,
  UNSUBSCRIBE = 12,
  MIN = ACK,
  MAX = UNSUBSCRIBE
};

inline const char **EnumNamesAction() {
  static const char *names[] = { "ACK", "GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH", "RESPONSE", "SUBSCRIBE", "UNSUBSCRIBE", nullptr };
  return names;
}

inline const char *EnumNameAction(Action e) { return EnumNamesAction()[static_cast<int>(e)]; }

enum class Guarantee : int8_t {
  NONE = 0,
  AT_LEAST_ONCE = 1,
  MIN = NONE,
  MAX = AT_LEAST_ONCE
};

inline const char **EnumNamesGuarantee() {
  static const char *names[] = { "NONE", "AT_LEAST_ONCE", nullptr };
  return names;
}

inline const char *EnumNameGuarantee(Guarantee e) { return EnumNamesGuarantee()[static_cast<int>(e)]; }

struct ImqT : public flatbuffers::NativeTable {
  std::string MsgId;
  Action Action;
  uint16_t Status;
  std::string To;
  std::string From;
  std::string Path;
  std::string Authorization;
  bool Callback;
  std::vector<uint8_t> Body;
  std::vector<std::unique_ptr<KeyValT>> Meta;
  Guarantee Guarantee;
  int32_t Timeout;
};

struct Imq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MSGID = 4,
    VT_ACTION = 6,
    VT_STATUS = 8,
    VT_TO = 10,
    VT_FROM = 12,
    VT_PATH = 14,
    VT_AUTHORIZATION = 16,
    VT_CALLBACK = 18,
    VT_BODY = 20,
    VT_META = 22,
    VT_GUARANTEE = 24,
    VT_TIMEOUT = 26
  };
  const flatbuffers::String *MsgId() const { return GetPointer<const flatbuffers::String *>(VT_MSGID); }
  flatbuffers::String *mutable_MsgId() { return GetPointer<flatbuffers::String *>(VT_MSGID); }
  Action Action() const { return static_cast<Action>(GetField<int8_t>(VT_ACTION, 0)); }
  bool mutate_Action(Action _Action) { return SetField(VT_ACTION, static_cast<int8_t>(_Action)); }
  uint16_t Status() const { return GetField<uint16_t>(VT_STATUS, 0); }
  bool mutate_Status(uint16_t _Status) { return SetField(VT_STATUS, _Status); }
  const flatbuffers::String *To() const { return GetPointer<const flatbuffers::String *>(VT_TO); }
  flatbuffers::String *mutable_To() { return GetPointer<flatbuffers::String *>(VT_TO); }
  const flatbuffers::String *From() const { return GetPointer<const flatbuffers::String *>(VT_FROM); }
  flatbuffers::String *mutable_From() { return GetPointer<flatbuffers::String *>(VT_FROM); }
  const flatbuffers::String *Path() const { return GetPointer<const flatbuffers::String *>(VT_PATH); }
  flatbuffers::String *mutable_Path() { return GetPointer<flatbuffers::String *>(VT_PATH); }
  const flatbuffers::String *Authorization() const { return GetPointer<const flatbuffers::String *>(VT_AUTHORIZATION); }
  flatbuffers::String *mutable_Authorization() { return GetPointer<flatbuffers::String *>(VT_AUTHORIZATION); }
  bool Callback() const { return GetField<uint8_t>(VT_CALLBACK, 0) != 0; }
  bool mutate_Callback(bool _Callback) { return SetField(VT_CALLBACK, static_cast<uint8_t>(_Callback)); }
  const flatbuffers::Vector<uint8_t> *Body() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BODY); }
  flatbuffers::Vector<uint8_t> *mutable_Body() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BODY); }
  const flatbuffers::Vector<flatbuffers::Offset<KeyVal>> *Meta() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyVal>> *>(VT_META); }
  flatbuffers::Vector<flatbuffers::Offset<KeyVal>> *mutable_Meta() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<KeyVal>> *>(VT_META); }
  Guarantee Guarantee() const { return static_cast<Guarantee>(GetField<int8_t>(VT_GUARANTEE, 0)); }
  bool mutate_Guarantee(Guarantee _Guarantee) { return SetField(VT_GUARANTEE, static_cast<int8_t>(_Guarantee)); }
  int32_t Timeout() const { return GetField<int32_t>(VT_TIMEOUT, 0); }
  bool mutate_Timeout(int32_t _Timeout) { return SetField(VT_TIMEOUT, _Timeout); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MSGID) &&
           verifier.Verify(MsgId()) &&
           VerifyField<int8_t>(verifier, VT_ACTION) &&
           VerifyField<uint16_t>(verifier, VT_STATUS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TO) &&
           verifier.Verify(To()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FROM) &&
           verifier.Verify(From()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PATH) &&
           verifier.Verify(Path()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_AUTHORIZATION) &&
           verifier.Verify(Authorization()) &&
           VerifyField<uint8_t>(verifier, VT_CALLBACK) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BODY) &&
           verifier.Verify(Body()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_META) &&
           verifier.Verify(Meta()) &&
           verifier.VerifyVectorOfTables(Meta()) &&
           VerifyField<int8_t>(verifier, VT_GUARANTEE) &&
           VerifyField<int32_t>(verifier, VT_TIMEOUT) &&
           verifier.EndTable();
  }
  ImqT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct ImqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MsgId(flatbuffers::Offset<flatbuffers::String> MsgId) { fbb_.AddOffset(Imq::VT_MSGID, MsgId); }
  void add_Action(Action Action) { fbb_.AddElement<int8_t>(Imq::VT_ACTION, static_cast<int8_t>(Action), 0); }
  void add_Status(uint16_t Status) { fbb_.AddElement<uint16_t>(Imq::VT_STATUS, Status, 0); }
  void add_To(flatbuffers::Offset<flatbuffers::String> To) { fbb_.AddOffset(Imq::VT_TO, To); }
  void add_From(flatbuffers::Offset<flatbuffers::String> From) { fbb_.AddOffset(Imq::VT_FROM, From); }
  void add_Path(flatbuffers::Offset<flatbuffers::String> Path) { fbb_.AddOffset(Imq::VT_PATH, Path); }
  void add_Authorization(flatbuffers::Offset<flatbuffers::String> Authorization) { fbb_.AddOffset(Imq::VT_AUTHORIZATION, Authorization); }
  void add_Callback(bool Callback) { fbb_.AddElement<uint8_t>(Imq::VT_CALLBACK, static_cast<uint8_t>(Callback), 0); }
  void add_Body(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Body) { fbb_.AddOffset(Imq::VT_BODY, Body); }
  void add_Meta(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyVal>>> Meta) { fbb_.AddOffset(Imq::VT_META, Meta); }
  void add_Guarantee(Guarantee Guarantee) { fbb_.AddElement<int8_t>(Imq::VT_GUARANTEE, static_cast<int8_t>(Guarantee), 0); }
  void add_Timeout(int32_t Timeout) { fbb_.AddElement<int32_t>(Imq::VT_TIMEOUT, Timeout, 0); }
  ImqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ImqBuilder &operator=(const ImqBuilder &);
  flatbuffers::Offset<Imq> Finish() {
    auto o = flatbuffers::Offset<Imq>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> MsgId = 0,
    Action Action = Action::ACK,
    uint16_t Status = 0,
    flatbuffers::Offset<flatbuffers::String> To = 0,
    flatbuffers::Offset<flatbuffers::String> From = 0,
    flatbuffers::Offset<flatbuffers::String> Path = 0,
    flatbuffers::Offset<flatbuffers::String> Authorization = 0,
    bool Callback = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Body = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyVal>>> Meta = 0,
    Guarantee Guarantee = Guarantee::NONE,
    int32_t Timeout = 0) {
  ImqBuilder builder_(_fbb);
  builder_.add_Timeout(Timeout);
  builder_.add_Meta(Meta);
  builder_.add_Body(Body);
  builder_.add_Authorization(Authorization);
  builder_.add_Path(Path);
  builder_.add_From(From);
  builder_.add_To(To);
  builder_.add_MsgId(MsgId);
  builder_.add_Status(Status);
  builder_.add_Guarantee(Guarantee);
  builder_.add_Callback(Callback);
  builder_.add_Action(Action);
  return builder_.Finish();
}

inline flatbuffers::Offset<Imq> CreateImqDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *MsgId = nullptr,
    Action Action = Action::ACK,
    uint16_t Status = 0,
    const char *To = nullptr,
    const char *From = nullptr,
    const char *Path = nullptr,
    const char *Authorization = nullptr,
    bool Callback = false,
    const std::vector<uint8_t> *Body = nullptr,
    const std::vector<flatbuffers::Offset<KeyVal>> *Meta = nullptr,
    Guarantee Guarantee = Guarantee::NONE,
    int32_t Timeout = 0) {
  return CreateImq(_fbb, MsgId ? _fbb.CreateString(MsgId) : 0, Action, Status, To ? _fbb.CreateString(To) : 0, From ? _fbb.CreateString(From) : 0, Path ? _fbb.CreateString(Path) : 0, Authorization ? _fbb.CreateString(Authorization) : 0, Callback, Body ? _fbb.CreateVector<uint8_t>(*Body) : 0, Meta ? _fbb.CreateVector<flatbuffers::Offset<KeyVal>>(*Meta) : 0, Guarantee, Timeout);
}

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb, const ImqT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct KeyValT : public flatbuffers::NativeTable {
  std::string Key;
  std::string Value;
};

struct KeyVal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *Key() const { return GetPointer<const flatbuffers::String *>(VT_KEY); }
  flatbuffers::String *mutable_Key() { return GetPointer<flatbuffers::String *>(VT_KEY); }
  bool KeyCompareLessThan(const KeyVal *o) const { return *Key() < *o->Key(); }
  int KeyCompareWithValue(const char *val) const { return strcmp(Key()->c_str(), val); }
  const flatbuffers::String *Value() const { return GetPointer<const flatbuffers::String *>(VT_VALUE); }
  flatbuffers::String *mutable_Value() { return GetPointer<flatbuffers::String *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_KEY) &&
           verifier.Verify(Key()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(Value()) &&
           verifier.EndTable();
  }
  KeyValT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
};

struct KeyValBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Key(flatbuffers::Offset<flatbuffers::String> Key) { fbb_.AddOffset(KeyVal::VT_KEY, Key); }
  void add_Value(flatbuffers::Offset<flatbuffers::String> Value) { fbb_.AddOffset(KeyVal::VT_VALUE, Value); }
  KeyValBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  KeyValBuilder &operator=(const KeyValBuilder &);
  flatbuffers::Offset<KeyVal> Finish() {
    auto o = flatbuffers::Offset<KeyVal>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, KeyVal::VT_KEY);  // Key
    return o;
  }
};

inline flatbuffers::Offset<KeyVal> CreateKeyVal(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> Key = 0,
    flatbuffers::Offset<flatbuffers::String> Value = 0) {
  KeyValBuilder builder_(_fbb);
  builder_.add_Value(Value);
  builder_.add_Key(Key);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyVal> CreateKeyValDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *Key = nullptr,
    const char *Value = nullptr) {
  return CreateKeyVal(_fbb, Key ? _fbb.CreateString(Key) : 0, Value ? _fbb.CreateString(Value) : 0);
}

inline flatbuffers::Offset<KeyVal> CreateKeyVal(flatbuffers::FlatBufferBuilder &_fbb, const KeyValT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

inline ImqT *Imq::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ImqT();
  { auto _e = MsgId(); if (_e) _o->MsgId = _e->str(); };
  { auto _e = Action(); _o->Action = _e; };
  { auto _e = Status(); _o->Status = _e; };
  { auto _e = To(); if (_e) _o->To = _e->str(); };
  { auto _e = From(); if (_e) _o->From = _e->str(); };
  { auto _e = Path(); if (_e) _o->Path = _e->str(); };
  { auto _e = Authorization(); if (_e) _o->Authorization = _e->str(); };
  { auto _e = Callback(); _o->Callback = _e; };
  { auto _e = Body(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Body.push_back(_e->Get(_i)); } } };
  { auto _e = Meta(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Meta.push_back(std::unique_ptr<KeyValT>(_e->Get(_i)->UnPack(resolver))); } } };
  { auto _e = Guarantee(); _o->Guarantee = _e; };
  { auto _e = Timeout(); _o->Timeout = _e; };
  return _o;
}

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb, const ImqT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateImq(_fbb,
    _o->MsgId.size() ? _fbb.CreateString(_o->MsgId) : 0,
    _o->Action,
    _o->Status,
    _o->To.size() ? _fbb.CreateString(_o->To) : 0,
    _o->From.size() ? _fbb.CreateString(_o->From) : 0,
    _o->Path.size() ? _fbb.CreateString(_o->Path) : 0,
    _o->Authorization.size() ? _fbb.CreateString(_o->Authorization) : 0,
    _o->Callback,
    _o->Body.size() ? _fbb.CreateVector(_o->Body) : 0,
    _o->Meta.size() ? _fbb.CreateVector<flatbuffers::Offset<KeyVal>>(_o->Meta.size(), [&](size_t i) { return CreateKeyVal(_fbb, _o->Meta[i].get(), rehasher); }) : 0,
    _o->Guarantee,
    _o->Timeout);
}

inline KeyValT *KeyVal::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new KeyValT();
  { auto _e = Key(); if (_e) _o->Key = _e->str(); };
  { auto _e = Value(); if (_e) _o->Value = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<KeyVal> CreateKeyVal(flatbuffers::FlatBufferBuilder &_fbb, const KeyValT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateKeyVal(_fbb,
    _fbb.CreateString(_o->Key),
    _o->Value.size() ? _fbb.CreateString(_o->Value) : 0);
}

inline const IndisMQ::Imq *GetImq(const void *buf) {
  return flatbuffers::GetRoot<IndisMQ::Imq>(buf);
}

inline Imq *GetMutableImq(void *buf) {
  return flatbuffers::GetMutableRoot<Imq>(buf);
}

inline const char *ImqIdentifier() {
  return "0001";
}

inline bool ImqBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(buf, ImqIdentifier());
}

inline bool VerifyImqBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<IndisMQ::Imq>(ImqIdentifier());
}

inline void FinishImqBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<IndisMQ::Imq> root) {
  fbb.Finish(root, ImqIdentifier());
}

inline std::unique_ptr<ImqT> UnPackImq(const void *buf, const flatbuffers::resolver_function_t *resolver = nullptr) {
  return std::unique_ptr<ImqT>(GetImq(buf)->UnPack(resolver));
}

}  // namespace IndisMQ

#endif  // FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_
